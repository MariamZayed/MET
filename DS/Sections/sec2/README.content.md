# 🧩 Arrays في C++

## 🔹 مقدمة

الـ **Array** هي عبارة عن **مجموعة من العناصر (elements)** من نفس الـ **data type**، بتتخزن في **أماكن متجاورة في الذاكرة (contiguous memory)**.
بنستخدمها عشان نحفظ مجموعة بيانات كبيرة بطريقة منظمة وسهلة الوصول.

---

## 🔹 Traversal (المرور على عناصر المصفوفة)

عملية **Traversal** معناها إننا نمر على كل عنصر في الـ array ونعمل عليه عملية معينة، زي الطباعة أو الجمع أو التحقق من شرط معين.

### 💻 مثال:

```cpp
#include <iostream>
using namespace std;

int main() {
    int arr[] = {10, 20, 30, 40, 50};
    int n = sizeof(arr) / sizeof(arr[0]); // عدد العناصر

    cout << "Elements of the array:\n";
    for (int i = 0; i < n; i++) {
        cout << "arr[" << i << "] = " << arr[i] << endl;
    }

    return 0;
}
```

🔸 الفكرة هنا إننا استخدمنا **for loop** علشان نمر على كل element من أول index = 0 لحد آخر عنصر.

---

## 🔹 Insertion (الإدخال)

عملية **Insertion** معناها إننا نضيف **عنصر جديد** داخل الـ array في مكان معين (index) بنحدده.

بما إن الـ arrays في C++ حجمها ثابت، فلازم نتأكد إن في مساحة فاضية قبل ما نضيف عنصر جديد.

---

## 🔸 أولًا: Insertion في Unsorted Array

لو المصفوفة غير مرتبة، ممكن نضيف العنصر الجديد في أي مكان نختاره، أو ببساطة في نهاية المصفوفة.

### 💻 مثال على Insertion في Array غير مرتبة:

```cpp
#include <iostream>
using namespace std;

int main() {
    int arr[10] = {5, 2, 8, 9, 1};
    int n = 5;        // عدد العناصر الحالية
    int item = 7;      // العنصر الجديد

    cout << "Array before insertion:\n";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }

    // نضيف العنصر الجديد في النهاية
    arr[n] = item;
    n++;

    cout << "\n\nArray after insertion (unsorted):\n";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }

    return 0;
}
```

---

### 🧠 شرح الكود:

1. بدأنا بمصفوفة فيها 5 عناصر.
2. أضفنا العنصر الجديد في آخر مكان متاح.
3. زودنا عدد العناصر `n` بعد الإضافة.

---

### 💡 ملاحظات:

* في المصفوفة غير المرتبة مش مهم مكان الإدخال.
* نقدر نضيف في النهاية مباشرة بدون تحريك.
* **Time Complexity = O(1)** (لأننا بنضيف في النهاية فقط).

---

## 🔸 ثانيًا: Insertion في Sorted Array

لو المصفوفة **مرتبة تصاعديًا**، لازم نحافظ على ترتيبها بعد الإضافة،
وده معناه إننا نحتاج نحرك العناصر لليمين قبل ما نحط العنصر الجديد في مكانه الصحيح.

### 💻 مثال على Insertion في Array مرتبة:

```cpp
#include <iostream>
using namespace std;

int main() {
    int arr[10] = {1, 3, 5, 7, 9};
    int n = 5;        // عدد العناصر الحالية
    int item = 6;      // العنصر الجديد
    int i = n - 1;

    cout << "Array before insertion:\n";
    for (int j = 0; j < n; j++) {
        cout << arr[j] << " ";
    }

    // نحرك العناصر اللي أكبر من العنصر الجديد
    while (i >= 0 && arr[i] > item) {
        arr[i + 1] = arr[i];
        i--;
    }

    // نحط العنصر الجديد في مكانه الصحيح
    arr[i + 1] = item;
    n++;

    cout << "\n\nArray after insertion (sorted):\n";
    for (int j = 0; j < n; j++) {
        cout << arr[j] << " ";
    }

    return 0;
}
```

---

### 🧠 شرح الكود:

1. بدأنا بمصفوفة مرتبة `[1, 3, 5, 7, 9]`.
2. عايزين نضيف `6`، فبنقارن من آخر عنصر.
3. كل عنصر أكبر من `6` بيتحرك خطوة لليمين.
4. لما نوصل للمكان الصحيح، بنحط `6`.
5. نحدث قيمة `n` بعد الإدخال.

---

### 💡 ملاحظات:

* لازم نتحقق من وجود مساحة فاضية.
* كل ما يكون العنصر المفروض يضاف في البداية، الوقت يزيد.
* **Time Complexity = O(n)** لأننا بنحرك عناصر.

---

### 📊 مقارنة بين الحالتين:

| الحالة         | طريقة الإدخال              | Time Complexity | هل في تحريك؟ |
| -------------- | -------------------------- | --------------- | ------------ |
| Unsorted Array | نضيف في النهاية أو أي مكان | O(1)            | ❌ لا         |
| Sorted Array   | نضيف في مكانه الصحيح       | O(n)            | ✅ نعم        |
